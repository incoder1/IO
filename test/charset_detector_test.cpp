/*
 *
 * Copyright (c) 2016-2023
 * Viktor Gubin
 *
 * Use, modification and distribution are subject to the
 * Boost Software License, Version 1.0. (See accompanying file
 * LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 *
 */
#include "stdafx.hpp"

#include <io/textapi/charset_detector.hpp>
#include <io/core/console.hpp>

#include  "io/textapi/detail/latin1_prober.hpp"
#include  "io/textapi/detail/utf8_prober.hpp"
#include  "io/textapi/detail/single_byte_group_prober.hpp"

#include <cmath>

charset_detector_fixture::charset_detector_fixture():
	testing::Test(),
	ec_()
{}

TEST_F(charset_detector_fixture, prober_should_filter_without_english_letters)
{
	const char* UTF8_STR = "abcdefghijklmnopqrstuvwxyzПривет!Hello!Χαιρετίσματα!World!ABCDEFGHIJKLMNOPQRSTUVWXYZგამარჯობა!こんにちは!您好!abcdefghijklmnopqrstuvwxyz";
	const char* EXPECTED = "Привет!!Χαιρετίσματα!!გამარჯობა!こんにちは!您好!";
	io::byte_buffer buff = io::detail::prober::filter_without_english_letters(ec_, reinterpret_cast<const uint8_t*>(UTF8_STR), io_strlen(UTF8_STR) );
	ASSERT_FALSE(ec_);
	ASSERT_STREQ( EXPECTED, buff.position().cdata() );
}

TEST_F(charset_detector_fixture, prober_should_filter_with_english_letters)
{
	const char* UTF8_STR = "0123456789,<Hello>,{Привет},[Χαιρετίσματα],||გამარჯობა||--こんにちは--,__您好__!";
	const char* EXPECTED = "HelloПриветΧαιρετίσματαგამარჯობაこんにちは您好";
	io::byte_buffer buff = io::detail::prober::filter_with_english_letters(ec_, reinterpret_cast<const uint8_t*>(UTF8_STR),  io_strlen(UTF8_STR) );
	ASSERT_FALSE(ec_);
	ASSERT_STREQ( EXPECTED, buff.position().cdata() );
}

TEST_F(charset_detector_fixture, prober_should_detect_latin1_from_str_and_ignore_multibyte)
{
	io::detail::s_prober prb = io::detail::latin1_prober::create(ec_);
	ASSERT_FALSE(ec_);
	const char* LATIN1_ONLY = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz,.!?-+=";
	auto actual = prb->handle_data(ec_, reinterpret_cast<const uint8_t*>(LATIN1_ONLY), io_strlen(LATIN1_ONLY) );
	ASSERT_FALSE(ec_);
	ASSERT_EQ(io::detail::prober::state_t::detecting, actual);
	ASSERT_FLOAT_EQ( 1.0F,  prb->confidence() );
	prb->reset();
	const char* UTF8_STR = "Hello!Привет!Χαιρετίσματα!გამარჯობა!こんにちは!您好!";
	actual = prb->handle_data(ec_, reinterpret_cast<const uint8_t*>(UTF8_STR), io_strlen(UTF8_STR) );
	ASSERT_EQ(io::detail::prober::state_t::notme, actual);
	ASSERT_FLOAT_EQ( 0.01F,  prb->confidence() );
}

TEST_F(charset_detector_fixture, prober_should_detect_utf8_by_from_long_data_mixed_single_and_multibyte_characters)
{
	io::detail::s_prober prb = io::detail::utf8_prober::create(ec_);
	ASSERT_FALSE(ec_);
	const char* UTF8_STR_LONG = "abcdefghijklmnopqrstuvwxyzПривет!Hello!Χαιρετίσματα!World!ABCDEFGHIJKLMNOPQRSTUVWXYZგამარჯობა!こんにちは!您好!abcdefghijklmnopqrstuvwxyz";
	auto actual = prb->handle_data(ec_, reinterpret_cast<const uint8_t*>(UTF8_STR_LONG), io_strlen(UTF8_STR_LONG) );
	ASSERT_EQ(io::detail::prober::state_t::found, actual);
	ASSERT_FLOAT_EQ( 0.99F,  prb->confidence() );
}

TEST_F(charset_detector_fixture, prober_should_detect_utf8_by_short_data_multibyte_characters)
{
	io::detail::s_prober prb = io::detail::utf8_prober::create(ec_);
	ASSERT_FALSE(ec_);
	const char* UTF8_SHORT = "ΑΒΓΔΕ";
	auto actual = prb->handle_data(ec_, reinterpret_cast<const uint8_t*>(UTF8_SHORT), io_strlen(UTF8_SHORT) );
	ASSERT_FALSE(ec_);
	ASSERT_EQ(io::detail::prober::state_t::found, actual);
	ASSERT_TRUE( std::trunc( prb->confidence() * 100.0F) >= 95 );
}

TEST_F(charset_detector_fixture, prober_should_detect_koi8r)
{
	constexpr const std::size_t EFECTIVE_CODESET_LEN = 63;
	uint8_t koi8r[EFECTIVE_CODESET_LEN];
	uint8_t ch = 192;
	for(std::size_t i=0; i < EFECTIVE_CODESET_LEN; i++) {
		koi8r[i] = ch++;
	}
	io::detail::s_prober kio8r_prober = io::detail::single_byte_prober::create(ec_, io::detail::koi8r_sequence_model(), false );
	ASSERT_FALSE(ec_);
	io::detail::prober::state_t actual;
	for(std::size_t i=0; i < 32; i++) {
	 	actual = kio8r_prober->handle_data(ec_,koi8r, EFECTIVE_CODESET_LEN);
	 	ASSERT_FALSE(ec_);
	}
	ASSERT_EQ(io::detail::prober::state_t::found, actual);
}

TEST_F(charset_detector_fixture, prober_should_detect_windows_1251)
{
	constexpr const std::size_t EFECTIVE_CODESET_LEN = 128;
	uint8_t cp1251[EFECTIVE_CODESET_LEN];
	uint8_t ch = 128;
	for(std::size_t i=0; i < EFECTIVE_CODESET_LEN; i++) {
		cp1251[i] = ch++;
	}
	io::detail::s_prober cp1251_prober = io::detail::single_byte_prober::create(ec_, io::detail::win1251_sequence_model(), false );
	ASSERT_FALSE(ec_);
	io::detail::prober::state_t actual;
	for(std::size_t i=0; i < 32; i++) {
	 	actual = cp1251_prober->handle_data(ec_,cp1251, EFECTIVE_CODESET_LEN);
	 	ASSERT_FALSE(ec_);
	}
	ASSERT_EQ(io::detail::prober::state_t::found, actual);
}

TEST_F(charset_detector_fixture, prober_should_detect_iso_8859_5)
{
	constexpr const std::size_t EFECTIVE_CODESET_LEN = 79;
	uint8_t iso_8859_5[EFECTIVE_CODESET_LEN];
	uint8_t ch = 161;
	for(std::size_t i=0; i < EFECTIVE_CODESET_LEN; i++) {
		iso_8859_5[i] = ch++;
	}
	io::detail::s_prober iso_8859_5_prober = io::detail::single_byte_prober::create(ec_, io::detail::iso_8859_5_sequence_model(), false );
	ASSERT_FALSE(ec_);
	io::detail::prober::state_t actual;
	for(std::size_t i=0; i < 32; i++) {
	 	actual = iso_8859_5_prober->handle_data(ec_,iso_8859_5, EFECTIVE_CODESET_LEN);
	 	ASSERT_FALSE(ec_);
	}
	ASSERT_EQ(io::detail::prober::state_t::found, actual);
}

TEST_F(charset_detector_fixture, prober_should_detect_windows_1253)
{
	constexpr const std::size_t EFECTIVE_CODESET_LEN = 61;
	uint8_t cp1253[EFECTIVE_CODESET_LEN];
	uint8_t ch = 193;
	for(std::size_t i=0; i < EFECTIVE_CODESET_LEN; i++) {
		cp1253[i] = ch++;
	}
	io::detail::s_prober cp1253_prober = io::detail::single_byte_prober::create(ec_, io::detail::win1253_sequence_model(), false );
	ASSERT_FALSE(ec_);
	io::detail::prober::state_t actual;
	for(std::size_t i=0; i < 32; i++) {
	 	actual = cp1253_prober->handle_data(ec_, cp1253, EFECTIVE_CODESET_LEN);
	 	ASSERT_FALSE(ec_);
	}
	ASSERT_EQ(io::detail::prober::state_t::found, actual);
}

TEST_F(charset_detector_fixture, prober_should_detect_iso_8859_7)
{
	constexpr const std::size_t EFECTIVE_CODESET_LEN = 61;
	uint8_t iso_8859_7[EFECTIVE_CODESET_LEN];
	uint8_t ch = 193;
	for(std::size_t i=0; i < EFECTIVE_CODESET_LEN; i++) {
		iso_8859_7[i] = ch++;
	}
	io::detail::s_prober iso_8859_7_prober = io::detail::single_byte_prober::create(ec_, io::detail::iso_8859_7_sequence_model(), false );
	ASSERT_FALSE(ec_);
	io::detail::prober::state_t actual;
	for(std::size_t i=0; i < 32; i++) {
	 	actual = iso_8859_7_prober->handle_data(ec_,iso_8859_7, EFECTIVE_CODESET_LEN);
	 	ASSERT_FALSE(ec_);
	}
	ASSERT_EQ(io::detail::prober::state_t::found, actual);
}

/*
	Hungarian text for testing in CP1250 and ISO-8859-2 Latin2

	A C++ (ejtsd: cé plusz plusz) egy általános célú, magas szintű programozási nyelv.
	Támogatja a procedurális, az objektumorientált és a generikus programozást, valamint az adatabsztrakciót.
	Napjainkban szinte minden operációs rendszer alá létezik C++ fordító.
	A nyelv a C programozási nyelv hatékonyságának megőrzése mellett törekszik a könnyebben megírható, karbantartható
	és újrahasznosítható kód írására, ez azonban sok kompromisszummal jár, erre utal, hogy általánosan elterjedt
	a mid-level minősítése is, bár szigorú értelemben véve egyértelműen magas szintű.

*/

TEST_F(charset_detector_fixture, prober_should_detect_windows_1250_hungarian)
{
	constexpr const std::size_t EFECTIVE_CODESET_LEN = 564;

	const uint8_t HUNG_WIN1250[EFECTIVE_CODESET_LEN] = {
		0x41,0x20,0x43,0x2B,0x2B,0x20,0x28,0x65,0x6A,0x74,0x73,0x64,0x3A,0x20,0x63,0xE9,
		0x20,0x70,0x6C,0x75,0x73,0x7A,0x20,0x70,0x6C,0x75,0x73,0x7A,0x29,0x20,0x65,0x67,
		0x79,0x20,0xE1,0x6C,0x74,0x61,0x6C,0xE1,0x6E,0x6F,0x73,0x20,0x63,0xE9,0x6C,0xFA,
		0x2C,0x20,0x6D,0x61,0x67,0x61,0x73,0x20,0x73,0x7A,0x69,0x6E,0x74,0xFB,0x20,0x70,
		0x72,0x6F,0x67,0x72,0x61,0x6D,0x6F,0x7A,0xE1,0x73,0x69,0x20,0x6E,0x79,0x65,0x6C,
		0x76,0x2E,0x20,0x54,0xE1,0x6D,0x6F,0x67,0x61,0x74,0x6A,0x61,0x20,0x61,0x20,0x70,
		0x72,0x6F,0x63,0x65,0x64,0x75,0x72,0xE1,0x6C,0x69,0x73,0x2C,0x20,0x61,0x7A,0x20,
		0x6F,0x62,0x6A,0x65,0x6B,0x74,0x75,0x6D,0x6F,0x72,0x69,0x65,0x6E,0x74,0xE1,0x6C,
		0x74,0x20,0xE9,0x73,0x20,0x61,0x20,0x67,0x65,0x6E,0x65,0x72,0x69,0x6B,0x75,0x73,
		0x20,0x70,0x72,0x6F,0x67,0x72,0x61,0x6D,0x6F,0x7A,0xE1,0x73,0x74,0x2C,0x20,0x76,
		0x61,0x6C,0x61,0x6D,0x69,0x6E,0x74,0x20,0x61,0x7A,0x20,0x61,0x64,0x61,0x74,0x61,
		0x62,0x73,0x7A,0x74,0x72,0x61,0x6B,0x63,0x69,0xF3,0x74,0x2E,0x20,0x4E,0x61,0x70,
		0x6A,0x61,0x69,0x6E,0x6B,0x62,0x61,0x6E,0x20,0x73,0x7A,0x69,0x6E,0x74,0x65,0x20,
		0x6D,0x69,0x6E,0x64,0x65,0x6E,0x20,0x6F,0x70,0x65,0x72,0xE1,0x63,0x69,0xF3,0x73,
		0x20,0x72,0x65,0x6E,0x64,0x73,0x7A,0x65,0x72,0x20,0x61,0x6C,0xE1,0x20,0x6C,0xE9,
		0x74,0x65,0x7A,0x69,0x6B,0x20,0x43,0x2B,0x2B,0x20,0x66,0x6F,0x72,0x64,0xED,0x74,
		0xF3,0x2E,0x20,0x41,0x20,0x6E,0x79,0x65,0x6C,0x76,0x20,0x61,0x20,0x43,0x20,0x70,
		0x72,0x6F,0x67,0x72,0x61,0x6D,0x6F,0x7A,0xE1,0x73,0x69,0x20,0x6E,0x79,0x65,0x6C,
		0x76,0x20,0x68,0x61,0x74,0xE9,0x6B,0x6F,0x6E,0x79,0x73,0xE1,0x67,0xE1,0x6E,0x61,
		0x6B,0x20,0x6D,0x65,0x67,0xF5,0x72,0x7A,0xE9,0x73,0x65,0x20,0x6D,0x65,0x6C,0x6C,
		0x65,0x74,0x74,0x20,0x74,0xF6,0x72,0x65,0x6B,0x73,0x7A,0x69,0x6B,0x20,0x61,0x20,
		0x6B,0xF6,0x6E,0x6E,0x79,0x65,0x62,0x62,0x65,0x6E,0x20,0x6D,0x65,0x67,0xED,0x72,
		0x68,0x61,0x74,0xF3,0x2C,0x20,0x6B,0x61,0x72,0x62,0x61,0x6E,0x74,0x61,0x72,0x74,
		0x68,0x61,0x74,0xF3,0x20,0xE9,0x73,0x20,0xFA,0x6A,0x72,0x61,0x68,0x61,0x73,0x7A,
		0x6E,0x6F,0x73,0xED,0x74,0x68,0x61,0x74,0xF3,0x20,0x6B,0xF3,0x64,0x20,0xED,0x72,
		0xE1,0x73,0xE1,0x72,0x61,0x2C,0x20,0x65,0x7A,0x20,0x61,0x7A,0x6F,0x6E,0x62,0x61,
		0x6E,0x20,0x73,0x6F,0x6B,0x20,0x6B,0x6F,0x6D,0x70,0x72,0x6F,0x6D,0x69,0x73,0x73,
		0x7A,0x75,0x6D,0x6D,0x61,0x6C,0x20,0x6A,0xE1,0x72,0x2C,0x20,0x65,0x72,0x72,0x65,
		0x20,0x75,0x74,0x61,0x6C,0x2C,0x20,0x68,0x6F,0x67,0x79,0x20,0xE1,0x6C,0x74,0x61,
		0x6C,0xE1,0x6E,0x6F,0x73,0x61,0x6E,0x20,0x65,0x6C,0x74,0x65,0x72,0x6A,0x65,0x64,
		0x74,0x20,0x61,0x20,0x6D,0x69,0x64,0x2D,0x6C,0x65,0x76,0x65,0x6C,0x20,0x6D,0x69,
		0x6E,0xF5,0x73,0xED,0x74,0xE9,0x73,0x65,0x20,0x69,0x73,0x2C,0x20,0x62,0xE1,0x72,
		0x20,0x73,0x7A,0x69,0x67,0x6F,0x72,0xFA,0x20,0xE9,0x72,0x74,0x65,0x6C,0x65,0x6D,
		0x62,0x65,0x6E,0x20,0x76,0xE9,0x76,0x65,0x20,0x65,0x67,0x79,0xE9,0x72,0x74,0x65,
		0x6C,0x6D,0xFB,0x65,0x6E,0x20,0x6D,0x61,0x67,0x61,0x73,0x20,0x73,0x7A,0x69,0x6E,
		0x74,0xFB,0x2E,0x20
	};

	io::detail::s_prober win1250_hung_prober = io::detail::single_byte_prober::create(ec_, io::detail::win1250_hungarian_sequence_model(), false );
	ASSERT_FALSE(ec_);
	io::detail::prober::state_t actual;
	for(std::size_t i=0; i < 4; i++) {
	 	actual = win1250_hung_prober->handle_data(ec_, HUNG_WIN1250, EFECTIVE_CODESET_LEN);
	 	ASSERT_FALSE(ec_);
	}
	ASSERT_EQ(io::detail::prober::state_t::found, actual);
}

TEST_F(charset_detector_fixture, prober_should_detect_iso_8859_2_hungarian)
{
	constexpr const std::size_t EFECTIVE_CODESET_LEN = 564;

	const uint8_t HUNG_TEXT_LATIN2[EFECTIVE_CODESET_LEN] = {
		0x41,0x20,0x43,0x2B,0x2B,0x20,0x28,0x65,0x6A,0x74,0x73,0x64,0x3A,0x20,0x63,0xE9,
		0x20,0x70,0x6C,0x75,0x73,0x7A,0x20,0x70,0x6C,0x75,0x73,0x7A,0x29,0x20,0x65,0x67,
		0x79,0x20,0xE1,0x6C,0x74,0x61,0x6C,0xE1,0x6E,0x6F,0x73,0x20,0x63,0xE9,0x6C,0xFA,
		0x2C,0x20,0x6D,0x61,0x67,0x61,0x73,0x20,0x73,0x7A,0x69,0x6E,0x74,0xFB,0x20,0x70,
		0x72,0x6F,0x67,0x72,0x61,0x6D,0x6F,0x7A,0xE1,0x73,0x69,0x20,0x6E,0x79,0x65,0x6C,
		0x76,0x2E,0x20,0x54,0xE1,0x6D,0x6F,0x67,0x61,0x74,0x6A,0x61,0x20,0x61,0x20,0x70,
		0x72,0x6F,0x63,0x65,0x64,0x75,0x72,0xE1,0x6C,0x69,0x73,0x2C,0x20,0x61,0x7A,0x20,
		0x6F,0x62,0x6A,0x65,0x6B,0x74,0x75,0x6D,0x6F,0x72,0x69,0x65,0x6E,0x74,0xE1,0x6C,
		0x74,0x20,0xE9,0x73,0x20,0x61,0x20,0x67,0x65,0x6E,0x65,0x72,0x69,0x6B,0x75,0x73,
		0x20,0x70,0x72,0x6F,0x67,0x72,0x61,0x6D,0x6F,0x7A,0xE1,0x73,0x74,0x2C,0x20,0x76,
		0x61,0x6C,0x61,0x6D,0x69,0x6E,0x74,0x20,0x61,0x7A,0x20,0x61,0x64,0x61,0x74,0x61,
		0x62,0x73,0x7A,0x74,0x72,0x61,0x6B,0x63,0x69,0xF3,0x74,0x2E,0x20,0x4E,0x61,0x70,
		0x6A,0x61,0x69,0x6E,0x6B,0x62,0x61,0x6E,0x20,0x73,0x7A,0x69,0x6E,0x74,0x65,0x20,
		0x6D,0x69,0x6E,0x64,0x65,0x6E,0x20,0x6F,0x70,0x65,0x72,0xE1,0x63,0x69,0xF3,0x73,
		0x20,0x72,0x65,0x6E,0x64,0x73,0x7A,0x65,0x72,0x20,0x61,0x6C,0xE1,0x20,0x6C,0xE9,
		0x74,0x65,0x7A,0x69,0x6B,0x20,0x43,0x2B,0x2B,0x20,0x66,0x6F,0x72,0x64,0xED,0x74,
		0xF3,0x2E,0x20,0x41,0x20,0x6E,0x79,0x65,0x6C,0x76,0x20,0x61,0x20,0x43,0x20,0x70,
		0x72,0x6F,0x67,0x72,0x61,0x6D,0x6F,0x7A,0xE1,0x73,0x69,0x20,0x6E,0x79,0x65,0x6C,
		0x76,0x20,0x68,0x61,0x74,0xE9,0x6B,0x6F,0x6E,0x79,0x73,0xE1,0x67,0xE1,0x6E,0x61,
		0x6B,0x20,0x6D,0x65,0x67,0xF5,0x72,0x7A,0xE9,0x73,0x65,0x20,0x6D,0x65,0x6C,0x6C,
		0x65,0x74,0x74,0x20,0x74,0xF6,0x72,0x65,0x6B,0x73,0x7A,0x69,0x6B,0x20,0x61,0x20,
		0x6B,0xF6,0x6E,0x6E,0x79,0x65,0x62,0x62,0x65,0x6E,0x20,0x6D,0x65,0x67,0xED,0x72,
		0x68,0x61,0x74,0xF3,0x2C,0x20,0x6B,0x61,0x72,0x62,0x61,0x6E,0x74,0x61,0x72,0x74,
		0x68,0x61,0x74,0xF3,0x20,0xE9,0x73,0x20,0xFA,0x6A,0x72,0x61,0x68,0x61,0x73,0x7A,
		0x6E,0x6F,0x73,0xED,0x74,0x68,0x61,0x74,0xF3,0x20,0x6B,0xF3,0x64,0x20,0xED,0x72,
		0xE1,0x73,0xE1,0x72,0x61,0x2C,0x20,0x65,0x7A,0x20,0x61,0x7A,0x6F,0x6E,0x62,0x61,
		0x6E,0x20,0x73,0x6F,0x6B,0x20,0x6B,0x6F,0x6D,0x70,0x72,0x6F,0x6D,0x69,0x73,0x73,
		0x7A,0x75,0x6D,0x6D,0x61,0x6C,0x20,0x6A,0xE1,0x72,0x2C,0x20,0x65,0x72,0x72,0x65,
		0x20,0x75,0x74,0x61,0x6C,0x2C,0x20,0x68,0x6F,0x67,0x79,0x20,0xE1,0x6C,0x74,0x61,
		0x6C,0xE1,0x6E,0x6F,0x73,0x61,0x6E,0x20,0x65,0x6C,0x74,0x65,0x72,0x6A,0x65,0x64,
		0x74,0x20,0x61,0x20,0x6D,0x69,0x64,0x2D,0x6C,0x65,0x76,0x65,0x6C,0x20,0x6D,0x69,
		0x6E,0xF5,0x73,0xED,0x74,0xE9,0x73,0x65,0x20,0x69,0x73,0x2C,0x20,0x62,0xE1,0x72,
		0x20,0x73,0x7A,0x69,0x67,0x6F,0x72,0xFA,0x20,0xE9,0x72,0x74,0x65,0x6C,0x65,0x6D,
		0x62,0x65,0x6E,0x20,0x76,0xE9,0x76,0x65,0x20,0x65,0x67,0x79,0xE9,0x72,0x74,0x65,
		0x6C,0x6D,0xFB,0x65,0x6E,0x20,0x6D,0x61,0x67,0x61,0x73,0x20,0x73,0x7A,0x69,0x6E,
		0x74,0xFB,0x2E,0x20
	};

	io::detail::s_prober iso_8859_2_hung_prober = io::detail::single_byte_prober::create(ec_, io::detail::iso_8859_2_hungarian_sequence_model(), false );
	ASSERT_FALSE(ec_);
	io::detail::prober::state_t actual;
	for(std::size_t i=0; i < 4; i++) {
	 	actual = iso_8859_2_hung_prober->handle_data(ec_, HUNG_TEXT_LATIN2, EFECTIVE_CODESET_LEN);
	 	ASSERT_FALSE(ec_);
	}
	ASSERT_EQ(io::detail::prober::state_t::found, actual);
}

